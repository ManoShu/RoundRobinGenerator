@using System.Text.RegularExpressions
@inject IJSRuntime JSRuntime

<div class="row">
    <textarea @bind="Lutas" id="txtLutas" name="txtLutas" placeholder="Lutas" class="col-sm-6" rows="5"></textarea>
    <textarea @bind="Sorteio" id="txtSorteio" name="txtSorteio" placeholder="Sorteio" class="col-sm-6"
        rows="5"></textarea>
</div>
<div class="row">
    <input type="button" class="btn btn-success col-sm-12" value="Gerar" @onclick="GerarRound" />
</div>
<section id="output_section">
<div class="row">
    <textarea @bind="Output" class="col-sm-12" rows="20" readonly="readonly"></textarea>
</div>
</section>

@code {

    const string MAGIC_REGEX =
        //@"(?<trash>.{0,})\t(?<data>\d{2}/\d{2}/\d{4})?\t(?<player1>[a-z-_.|ç•]{1,})\t(?<score1>[^\t]{0,})\t(?<score2>[^\t]{0,})\t(?<player2>.{1,})\n"
        //@"(?<trash>.{0,})\t(?<data>\d{2}/\d{2}/\d{4})?\t(?<player1>[a-z-_.|ç•]{1,})\t(?<score1>[^\t]{0,})\t(?<score2>[^\t]{0,})\t(?<player2>[^\n]{1,})\n"
        @"(?<trash>.{0,})\t(?<data>\d{2}/\d{2}/\d{4})?\t(?<player1>[á0-9/a-z-_.|ç• ]{1,})\t(?<score1>[^\t]{0,2})\t(?<score2>[^\t]{0,2})\t(?<player2>[^\n]{1,})\n"
        ;
    const string EMPTY_SLOT = "BYE";

    const int TIMEOUT_MATCHING = 1000;
    
    private string Lutas { get; set; }
    private string Sorteio { get; set; }
    private string Output { get; set; }

    private void GerarRound()
    {
        var theRegex = new Regex(MAGIC_REGEX,
        RegexOptions.IgnoreCase | RegexOptions.Multiline | RegexOptions.IgnorePatternWhitespace | RegexOptions.ExplicitCapture
        );

        var matchesBase = theRegex.Matches(Lutas);

        Output = string.Empty;

        var matchesAnteriores = new List<Tuple<string, string>>();


        Console.WriteLine("Matches base:");
        foreach (Match match in matchesBase)
        {
            var matchPlayers = new Tuple<string, string>(
            match.Groups["player1"].Value.Trim(),
            match.Groups["player2"].Value.Trim()
            );

            Console.WriteLine($"[{matchPlayers.Item1}] x [{matchPlayers.Item2}]");

            //TODO: ver se empates contam ou não
            //if(match.Groups["score1"].Value.Trim() != "-")
            {
                matchesAnteriores.Add(matchPlayers);
            }
        }

        var nomesSorteio = Sorteio
        .Split(new string[] { Environment.NewLine }, StringSplitOptions.RemoveEmptyEntries)
        .Select(x => x.Trim())
        .ToList();

        bool temMatchesRepetidas = true;
        int loopCount = 0;

        while (temMatchesRepetidas && loopCount <= TIMEOUT_MATCHING)
        {
            temMatchesRepetidas = false;
            for (int idx = 0; idx < nomesSorteio.Count; idx += 2)
            {
                var player1 = nomesSorteio[idx];
                var player2 = ((idx + 1) < nomesSorteio.Count) ? nomesSorteio[idx + 1] : EMPTY_SLOT;
                var thePair = new Tuple<string, string>(player1, player2);


                //verifica se o par de jogadores já se enfrentou anteriormente
                if (matchesAnteriores.Any(x => 
                (x.Item1 == player1 && x.Item2 == player2) ||
                (x.Item1 == player2 && x.Item2 == player1)                
                ))
                {
                    nomesSorteio.RemoveAt(idx + 1);//tira o player 2
                    //se não for o último
                    if(idx < nomesSorteio.Count - 1)
                    {
                        nomesSorteio.Add(player2); // adiciona no fim da lista
                    }
                    else
                    {
                        nomesSorteio.Insert(0, player2); // adiciona ao topo
                    }
                    temMatchesRepetidas = true; //continua a verificar
                    break;
                }
            }

            loopCount++;
        }

        if (temMatchesRepetidas)
        {
            Output += "SEM MATCHES. ERRO DE LÓGICA OU O RANKING ACABOU";
        }
        else
        {
            Console.WriteLine("Próximas matches:");
            for (int idx = 0; idx < nomesSorteio.Count; idx += 2)
            {
                var player1 = nomesSorteio[idx];
                var player2 = ((idx + 1) < nomesSorteio.Count) ? nomesSorteio[idx + 1] : EMPTY_SLOT;

                Console.WriteLine($"[{player1}] x [{player2}]");


                Output += $"{player1} x {player2}{Environment.NewLine}";
            }
        }



    }
}